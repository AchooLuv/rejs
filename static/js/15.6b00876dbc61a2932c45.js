webpackJsonp([15],{"1GfS":function(t,s){},"f+y1":function(t,s,a){"use strict";Object.defineProperty(s,"__esModule",{value:!0});var _={render:function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("div",{staticClass:"mpc-con"},[a("h2",[t._v("正则引擎的匹配规则")]),t._v(" "),t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),a("p",[t._v("来看一些简单的例子：")]),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),a("p",[a("span",{staticClass:"ins"},[t._v("用上例相同的正则表达式匹配字符串"),a("span",{staticClass:"reg"},[t._v("Lv")]),t._v("，在尝试"),a("span",{staticClass:"reg"},[t._v("u")]),t._v("之前，一切与上例过程相同，但此时的"),a("spann",{staticClass:"reg"},[t._v("u")]),t._v("无法匹配，引擎开始回溯至最近保存的状态（即该例中唯一的“备用状态”），即：")],1)]),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),t._m(18),t._v(" "),t._m(19),t._v(" "),t._m(20),t._v(" "),t._m(21),t._v(" "),t._m(22),t._v(" "),t._m(23),t._v(" "),t._m(24),t._v(" "),t._m(25),t._v(" "),t._m(26),t._v(" "),t._m(27),t._v(" "),t._m(28),t._v(" "),t._m(29),t._v(" "),t._m(30),t._v(" "),t._m(31),t._v(" "),t._m(32),t._v(" "),t._m(33)])},staticRenderFns:[function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("span",{staticClass:"ins"},[this._v("NFA引擎最重要的性质就是支持回溯，那么哪些情况下发生回溯呢？会发生回溯的情况有两种：匹配优先/忽略优先/占有优先量词；多选分支结构。回溯机制的基本原理不难理解，记住两个基本规则：")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h3",[s("span",{staticClass:"iconfont jh"},[this._v("")]),this._v("面对众多分支选择时，哪个分支应当首先选择？")])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("span",{staticClass:"ins"},[this._v("若需要在“进行尝试”和“跳过尝试”之间选择，对于匹配优先量词，引擎会优先选择“进行尝试”，而对于忽略优先量词，会选择“跳过尝试”！")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h3",[s("span",{staticClass:"iconfont jh"},[this._v("")]),this._v("回溯时，应选择哪个保存的状态？")])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("span",{staticClass:"ins"},[this._v("距离当前最近储存的选项（即备用状态）就是本地失败强制回溯时返回的！")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("span",{staticClass:"ins"},[this._v("对于NFA引擎来说，“备用状态”是引擎进行回溯的基础，“备用状态”会保存两个位置：正则表达式中的位置和未尝试的分支在字符串中的位置。在需要回溯时，“备用状态”告诉NFA引擎，匹配可以从此处开始！")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h3",[s("span",{staticClass:"iconfont jh"},[this._v("")]),this._v("匹配未进行回溯的例子")])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("span",{staticClass:"ins"},[this._v("使用正则表达式"),s("span",{staticClass:"reg"},[this._v("/Lu?v/")]),this._v("匹配字符串"),s("span",{staticClass:"reg"},[this._v("Luv")]),this._v("：当字符"),s("span",{staticClass:"reg"},[this._v("L")]),this._v("匹配成功后，匹配的当前状态如下")])])},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("table",{staticClass:"ms"},[a("thead",[a("tr",[a("th",[t._v("字符串状态")]),t._v(" "),a("th",[t._v("表达式状态")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("'L"),a("span",{staticClass:"trs"}),t._v("uv'")]),t._v(" "),a("td",[t._v("L"),a("span",{staticClass:"trs"}),t._v("u?v")])])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("span",{staticClass:"ins"},[this._v("现在该"),s("span",{staticClass:"reg"},[this._v("u?")]),this._v("匹配了，此时正则引擎需要决定：是尝试匹配呢？还是跳过匹配？因为"),s("span",{staticClass:"reg"},[this._v("?")]),this._v("是匹配优先量词，所以引擎会尝试匹配。但为了确保这个尝试最最终失败后能够恢复，NFA引擎会把以下状态添加到备用状态序列中：")])])},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("table",{staticClass:"ms"},[a("thead",[a("tr",[a("th",[t._v("字符串状态")]),t._v(" "),a("th",[t._v("表达式状态")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("'L"),a("span",{staticClass:"trs"}),t._v("uv'")]),t._v(" "),a("td",[t._v("Lu?"),a("span",{staticClass:"trs"}),t._v("v")])])])])},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("p",[a("span",{staticClass:"ins"},[t._v('该"备用状态"告诉引擎：下次匹配从正则表达式的'),a("span",{staticClass:"reg"},[t._v("u?")]),t._v("之后，字符串的字符"),a("span",{staticClass:"reg"},[t._v("v")]),t._v("之前开始匹配（即跳过"),a("span",{staticClass:"reg"},[t._v("u")]),t._v("匹配）。之后继续检查字符"),a("span",{staticClass:"reg"},[t._v("u")]),t._v("，能够匹配，状态更新为：")])])},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("table",{staticClass:"ms"},[a("thead",[a("tr",[a("th",[t._v("字符串状态")]),t._v(" "),a("th",[t._v("表达式状态")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("'Lu"),a("span",{staticClass:"trs"}),t._v("v'")]),t._v(" "),a("td",[t._v("Lu?"),a("span",{staticClass:"trs"}),t._v("v")])])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("span",{staticClass:"ins"},[this._v("继续检查字符"),s("span",{staticClass:"reg"},[this._v("v")]),this._v("，也能满足匹配，此时整个匹配完成，“备用状态”不在被需要，弃用“备用状态”，整个匹配结束。")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h3",[s("span",{staticClass:"iconfont jh"},[this._v("")]),this._v("匹配进行了回溯的例子")])},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("table",{staticClass:"ms"},[a("thead",[a("tr",[a("th",[t._v("字符串状态")]),t._v(" "),a("th",[t._v("表达式状态")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("'L"),a("span",{staticClass:"trs"}),t._v("v'")]),t._v(" "),a("td",[t._v("Lu?"),a("span",{staticClass:"trs"}),t._v("v")])])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("span",{staticClass:"ins"},[this._v("此时"),s("span",{staticClass:"reg"},[this._v("v")]),this._v("满足匹配，整个匹配结束！")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h3",[s("span",{staticClass:"iconfont jh"},[this._v("")]),this._v("进行了回溯但匹配失败的例子")])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("span",{staticClass:"ins"},[this._v("整个匹配宣告失败是发生在字符串和表达式均完成了所有回溯测试（备用状态）之后，而不是其中某一个完成其所有回溯测试之后！！！举个简单的例子，我们用同样的正则表达式匹配字符串"),s("span",{staticClass:"reg"},[this._v("Lue")]),this._v("，在尝试匹配字符"),s("span",{staticClass:"reg"},[this._v("u")]),this._v("之前有“备用状态”：")])])},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("table",{staticClass:"ms"},[a("thead",[a("tr",[a("th",[t._v("字符串状态")]),t._v(" "),a("th",[t._v("表达式状态")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("'L"),a("span",{staticClass:"trs"}),t._v("ue'")]),t._v(" "),a("td",[t._v("Lu?"),a("span",{staticClass:"trs"}),t._v("v")])])])])},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("p",[a("span",{staticClass:"ins"},[t._v("在"),a("span",{staticClass:"reg"},[t._v("u")]),t._v("匹配成功后，由于"),a("span",{staticClass:"reg"},[t._v("v")]),t._v("无法匹配"),a("span",{staticClass:"reg"},[t._v("e")]),t._v("，此时引擎回溯到最近保存状态，“交换”字符"),a("span",{staticClass:"reg"},[t._v("u")]),t._v("给"),a("span",{staticClass:"reg"},[t._v("v")]),t._v("匹配，依然不能满足匹配，该次回溯测试失败，但是此时不存在其它“备用状态”，所以字符串中当前位置的整个匹配宣告失败！")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("span",{staticClass:"ins"},[this._v("那么整个匹配就要宣告失败了吗？并不会！，匹配将重新开始于状态：")])])},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("table",{staticClass:"ms"},[a("thead",[a("tr",[a("th",[t._v("字符串状态")]),t._v(" "),a("th",[t._v("表达式状态")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("'L"),a("span",{staticClass:"trs"}),t._v("ue'")]),t._v(" "),a("td",[a("span",{staticClass:"trs"}),t._v("Lu?v")])])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("span",{staticClass:"ins"},[this._v("但这些均回溯测试以失败告终，最终整个表达式宣告匹配失败，结束匹配！")])])},function(){var t=this.$createElement,s=this._self._c||t;return s("h3",[s("span",{staticClass:"iconfont jh"},[this._v("")]),this._v("忽略优先的回溯匹配")])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("span",{staticClass:"ins"},[this._v("使用正则表达式"),s("span",{staticClass:"reg"},[this._v("/Lu??v/")]),this._v("匹配字符串"),s("span",{staticClass:"reg"},[this._v("Luv")]),this._v("。字符"),s("span",{staticClass:"reg"},[this._v("L")]),this._v("匹配之后的状态：")])])},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("table",{staticClass:"ms"},[a("thead",[a("tr",[a("th",[t._v("字符串状态")]),t._v(" "),a("th",[t._v("表达式状态")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("'L"),a("span",{staticClass:"trs"}),t._v("uv'")]),t._v(" "),a("td",[t._v("L"),a("span",{staticClass:"trs"}),t._v("u??v")])])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("span",{staticClass:"ins"},[this._v("现在该"),s("span",{staticClass:"reg"},[this._v("u?")]),this._v("匹配了，此时正则引擎需要决定：是尝试匹配呢？还是跳过匹配？因为"),s("span",{staticClass:"reg"},[this._v("??")]),this._v("是忽略优先量词，所以引擎会跳过匹配。但为了确保这个尝试最最终失败后能够恢复，NFA引擎会把以下状态添加到备用状态序列中：")])])},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("table",{staticClass:"ms"},[a("thead",[a("tr",[a("th",[t._v("字符串状态")]),t._v(" "),a("th",[t._v("表达式状态")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("'L"),a("span",{staticClass:"trs"}),t._v("uv'")]),t._v(" "),a("td",[t._v("L"),a("span",{staticClass:"trs"}),t._v("uv")])])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("span",{staticClass:"ins"},[this._v("保存“备用状态”后，沿着忽略匹配优先的路继续匹配：")])])},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("table",{staticClass:"ms"},[a("thead",[a("tr",[a("th",[t._v("字符串状态")]),t._v(" "),a("th",[t._v("表达式状态")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("'L"),a("span",{staticClass:"trs"}),t._v("uv'")]),t._v(" "),a("td",[t._v("Lu??"),a("span",{staticClass:"trs"}),t._v("v")])])])])},function(){var t=this.$createElement,s=this._self._c||t;return s("p",[s("span",{staticClass:"ins"},[this._v("但是此时"),s("span",{staticClass:"reg"},[this._v("v")]),this._v("无法匹配字符"),s("span",{staticClass:"reg"},[this._v("u")]),this._v("，引擎回溯至最近保存状态：")])])},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("table",{staticClass:"ms"},[a("thead",[a("tr",[a("th",[t._v("字符串状态")]),t._v(" "),a("th",[t._v("表达式状态")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("'L"),a("span",{staticClass:"trs"}),t._v("uv'")]),t._v(" "),a("td",[t._v("L"),a("span",{staticClass:"trs"}),t._v("uv")])])])])},function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("p",[a("span",{staticClass:"ins"},[t._v("此时"),a("span",{staticClass:"reg"},[t._v("u")]),t._v("能匹配字符"),a("span",{staticClass:"reg"},[t._v("u")]),t._v("，接下来的"),a("span",{staticClass:"reg"},[t._v("v")]),t._v("也能匹配字符"),a("span",{staticClass:"reg"},[t._v("v")]),t._v("，到此，整个匹配宣告成功，匹配结束！   和第一个例子对比会发现：虽然匹配优先"),a("span",{staticClass:"reg"},[t._v("Lu?v")]),t._v("和忽略优先"),a("span",{staticClass:"reg"},[t._v("Lu??v")]),t._v("得到的结果可能是（在本例中相同）相同的，但是回溯的过程是完全不同的！！！")])])}]};var v=a("VU/8")({name:"Recall"},_,!1,function(t){a("1GfS")},"data-v-07b5e9ae",null);s.default=v.exports}});
//# sourceMappingURL=15.6b00876dbc61a2932c45.js.map