{"version":3,"sources":["webpack:///src/pages/er/itself/Itself.vue","webpack:///./src/pages/er/itself/Itself.vue?a2fc","webpack:///./src/pages/er/itself/Itself.vue"],"names":["itself_Itself","render","this","$createElement","_self","_c","_m","staticRenderFns","_vm","_h","staticClass","_v","Component","__webpack_require__","normalizeComponent","name","ssrContext","__webpack_exports__"],"mappings":"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","file":"static/js/16.08503b2ac9480100df04.js","sourcesContent":["<template>\r\n  <div class=\"erc-con\">\r\n    <h2>优化正则表达式本身</h2>\r\n    <p>传统型NFA引擎让我们更应该关注正则表达式本身，从表达式本身上进行以下优化：</p>\r\n    <h3><span class=\"iconfont jh\">&#xe64a;</span>文字字符串连接优化</h3>\r\n    <p><span class=\"ins\">这应该是最基本的优化了，正则引擎能把<span class=\"reg\">orz</span>当成“一个元素”进行匹配，而不是<span class=\"reg\">o</span>\r\n    <span class=\"reg\">r</span>\r\n    <span class=\"reg\">z</span>。这样就能匹配迭代一个单元，而不是迭代三次。</span></p>\r\n    <h3><span class=\"iconfont jh\">&#xe64a;</span>化简量词优化</h3>\r\n    <p><span class=\"ins\">该优化避免了NFA引擎的大部分逐步处理开销。正则引擎中的主循环必须通用，才能处理引擎支持的所有结构，而通用意味着“速度慢”，所以将<span class=\"reg\">.*</span>之类的简单量词作为一个整体，此时正则引擎便不必按通用的办法处理，而使用专门化、高速的处理程序来绕过这些结构。比如：<span class=\"reg\">.*</span>和<span class=\"reg\">(?:.)*</span>在逻辑上是相等的，而<span class=\"reg\">.*</span>的性能远高于<span class=\"reg\">(?:.)*</span>。</span></p>\r\n    <h3><span class=\"iconfont jh\">&#xe64a;</span>消除非必要括号</h3>\r\n    <p><span class=\"ins\">若某种实现方式认为<span class=\"reg\">(?:.)*</span>与<span class=\"reg\">.*</span>等价时，则使用后者。</span></p>\r\n    <h3><span class=\"iconfont jh\">&#xe64a;</span>消除非必要字符组</h3>\r\n    <p><span class=\"ins\">包含单个字符的字符组是多余的。比如：可以将<span class=\"reg\">[.]</span>转换为<span class=\"reg\">\\.</span>。</span></p>\r\n    <h3><span class=\"iconfont jh\">&#xe64a;</span>忽略优先量词之后的字符优化</h3>\r\n    <p><span class=\"ins\">忽略优先量词通常比匹配优先量词要慢，如果忽略优先量词在捕获型括号内部，其控制权必须在括号内外切换，还会带来额外的开销。该优化的原理就是：若文字字符跟在忽略优先量词之后，只要引擎没有触及那个字符，忽略优先量词可以作为普通的匹配优先量词来处理。比如，预查一组字符，而不是特殊的一个字符<span class=\"reg\">['\"](.*?)[\"']</span>中的<span class=\"reg\">['\"]</span>。</span></p>\r\n    <h3><span class=\"iconfont jh\">&#xe64a;</span>避免“过度”回溯与指数级匹配</h3>\r\n    <p><span class=\"ins\">时刻注意，不要编写<span class=\"reg\">(.+)*</span>之类的量词结合结构，因为这种结构会制造指数级回溯，效率极低。</span></p>\r\n    <h3><span class=\"iconfont jh\">&#xe64a;</span>使用占有优先量词削减状态</h3>\r\n    <p><span class=\"ins\">由正常量词约束的对象匹配之后，会保留若干“在此处不进行匹配”的状态（即量词的每一轮迭代创建一个状态），而占有优先量词则不会保留这些状态（每一轮迭代时抛弃上一轮的备用状态）。比如：使用<span class=\"reg\">^\\w+:</span>来匹配<span class=\"reg\">Subject</span>,<span class=\"reg\">\\w+</span>匹配到字符串末尾时，最后的冒号无法匹配，回溯机制强迫<span class=\"reg\">\\w+</span>逐个交换字符，在每个位置对<span class=\"reg\">:</span>进行徒劳的尝试。可以使用固化分组<span class=\"reg\">^(?>\\w+):</span>或占有优先量词<span class=\"reg\">^\\w++:</span>来避免无谓的劳动。</span></p>\r\n    <h3><span class=\"iconfont jh\">&#xe64a;</span>使用量词进行等价转换</h3>\r\n    <p><span class=\"ins\">在JavaScript中，<span class=\"reg\">\\d\\d\\d\\d</span>和<span class=\"reg\">\\d{4}</span>在逻辑上虽然相同，但在性能上<span class=\"reg\">\\d{4}</span>远优于<span class=\"reg\">\\d\\d\\d\\d</span>的，所以，编写正则表达式出现类似的结构时，应尽量使用量词对其进行替换。</span></p>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: 'Itself'\r\n}\r\n</script>\r\n\r\n<style lang=\"scss\" scoped>\r\n@import 'sa/styles/var.scss';\r\n.erc-con {\r\n  @include tip;\r\n}\r\n</style>\r\n\n\n\n// WEBPACK FOOTER //\n// src/pages/er/itself/Itself.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"erc-con\"},[_c('h2',[_vm._v(\"优化正则表达式本身\")]),_vm._v(\" \"),_c('p',[_vm._v(\"传统型NFA引擎让我们更应该关注正则表达式本身，从表达式本身上进行以下优化：\")]),_vm._v(\" \"),_c('h3',[_c('span',{staticClass:\"iconfont jh\"},[_vm._v(\"\")]),_vm._v(\"文字字符串连接优化\")]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"ins\"},[_vm._v(\"这应该是最基本的优化了，正则引擎能把\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"orz\")]),_vm._v(\"当成“一个元素”进行匹配，而不是\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"o\")]),_vm._v(\" \"),_c('span',{staticClass:\"reg\"},[_vm._v(\"r\")]),_vm._v(\" \"),_c('span',{staticClass:\"reg\"},[_vm._v(\"z\")]),_vm._v(\"。这样就能匹配迭代一个单元，而不是迭代三次。\")])]),_vm._v(\" \"),_c('h3',[_c('span',{staticClass:\"iconfont jh\"},[_vm._v(\"\")]),_vm._v(\"化简量词优化\")]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"ins\"},[_vm._v(\"该优化避免了NFA引擎的大部分逐步处理开销。正则引擎中的主循环必须通用，才能处理引擎支持的所有结构，而通用意味着“速度慢”，所以将\"),_c('span',{staticClass:\"reg\"},[_vm._v(\".*\")]),_vm._v(\"之类的简单量词作为一个整体，此时正则引擎便不必按通用的办法处理，而使用专门化、高速的处理程序来绕过这些结构。比如：\"),_c('span',{staticClass:\"reg\"},[_vm._v(\".*\")]),_vm._v(\"和\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"(?:.)*\")]),_vm._v(\"在逻辑上是相等的，而\"),_c('span',{staticClass:\"reg\"},[_vm._v(\".*\")]),_vm._v(\"的性能远高于\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"(?:.)*\")]),_vm._v(\"。\")])]),_vm._v(\" \"),_c('h3',[_c('span',{staticClass:\"iconfont jh\"},[_vm._v(\"\")]),_vm._v(\"消除非必要括号\")]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"ins\"},[_vm._v(\"若某种实现方式认为\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"(?:.)*\")]),_vm._v(\"与\"),_c('span',{staticClass:\"reg\"},[_vm._v(\".*\")]),_vm._v(\"等价时，则使用后者。\")])]),_vm._v(\" \"),_c('h3',[_c('span',{staticClass:\"iconfont jh\"},[_vm._v(\"\")]),_vm._v(\"消除非必要字符组\")]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"ins\"},[_vm._v(\"包含单个字符的字符组是多余的。比如：可以将\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"[.]\")]),_vm._v(\"转换为\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"\\\\.\")]),_vm._v(\"。\")])]),_vm._v(\" \"),_c('h3',[_c('span',{staticClass:\"iconfont jh\"},[_vm._v(\"\")]),_vm._v(\"忽略优先量词之后的字符优化\")]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"ins\"},[_vm._v(\"忽略优先量词通常比匹配优先量词要慢，如果忽略优先量词在捕获型括号内部，其控制权必须在括号内外切换，还会带来额外的开销。该优化的原理就是：若文字字符跟在忽略优先量词之后，只要引擎没有触及那个字符，忽略优先量词可以作为普通的匹配优先量词来处理。比如，预查一组字符，而不是特殊的一个字符\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"['\\\"](.*?)[\\\"']\")]),_vm._v(\"中的\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"['\\\"]\")]),_vm._v(\"。\")])]),_vm._v(\" \"),_c('h3',[_c('span',{staticClass:\"iconfont jh\"},[_vm._v(\"\")]),_vm._v(\"避免“过度”回溯与指数级匹配\")]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"ins\"},[_vm._v(\"时刻注意，不要编写\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"(.+)*\")]),_vm._v(\"之类的量词结合结构，因为这种结构会制造指数级回溯，效率极低。\")])]),_vm._v(\" \"),_c('h3',[_c('span',{staticClass:\"iconfont jh\"},[_vm._v(\"\")]),_vm._v(\"使用占有优先量词削减状态\")]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"ins\"},[_vm._v(\"由正常量词约束的对象匹配之后，会保留若干“在此处不进行匹配”的状态（即量词的每一轮迭代创建一个状态），而占有优先量词则不会保留这些状态（每一轮迭代时抛弃上一轮的备用状态）。比如：使用\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"^\\\\w+:\")]),_vm._v(\"来匹配\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"Subject\")]),_vm._v(\",\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"\\\\w+\")]),_vm._v(\"匹配到字符串末尾时，最后的冒号无法匹配，回溯机制强迫\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"\\\\w+\")]),_vm._v(\"逐个交换字符，在每个位置对\"),_c('span',{staticClass:\"reg\"},[_vm._v(\":\")]),_vm._v(\"进行徒劳的尝试。可以使用固化分组\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"^(?>\\\\w+):\")]),_vm._v(\"或占有优先量词\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"^\\\\w++:\")]),_vm._v(\"来避免无谓的劳动。\")])]),_vm._v(\" \"),_c('h3',[_c('span',{staticClass:\"iconfont jh\"},[_vm._v(\"\")]),_vm._v(\"使用量词进行等价转换\")]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"ins\"},[_vm._v(\"在JavaScript中，\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"\\\\d\\\\d\\\\d\\\\d\")]),_vm._v(\"和\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"\\\\d{4}\")]),_vm._v(\"在逻辑上虽然相同，但在性能上\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"\\\\d{4}\")]),_vm._v(\"远优于\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"\\\\d\\\\d\\\\d\\\\d\")]),_vm._v(\"的，所以，编写正则表达式出现类似的结构时，应尽量使用量词对其进行替换。\")])])])}]\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-008ff46f\",\"hasScoped\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/pages/er/itself/Itself.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-008ff46f\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!sass-loader?{\\\"sourceMap\\\":true}!../../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./Itself.vue\")\n}\nvar normalizeComponent = require(\"!../../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../../../node_modules/vue-loader/lib/selector?type=script&index=0!./Itself.vue\"\nimport __vue_script__ from \"!!babel-loader!../../../../node_modules/vue-loader/lib/selector?type=script&index=0!./Itself.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-008ff46f\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../../node_modules/vue-loader/lib/selector?type=template&index=0!./Itself.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-008ff46f\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/pages/er/itself/Itself.vue\n// module id = null\n// module chunks = "],"sourceRoot":""}