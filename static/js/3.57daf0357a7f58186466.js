webpackJsonp([3],{aE13:function(t,s,e){"use strict";Object.defineProperty(s,"__esModule",{value:!0});var a={render:function(){var t=this.$createElement,s=this._self._c||t;return s("div",{staticClass:"er-con"},[s("h1",[this._v("高效正则")]),this._v(" "),this._m(0),this._v(" "),s("keep-alive",[s("router-view",{staticClass:"animated bounceInUp"})],1)],1)},staticRenderFns:[function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("p",[t._v("\n      得益于"),e("span",[t._v("JavaScript")]),t._v(" 的正则引擎是基于表达式的传统型NFA引擎，所以我们能对其进行精确的控制，让我们能够精心调校我们编写的正则表达式来达到预期的匹配结果！想要编写高效的正则表达式，提高取得结果的速度通常有两种优化方法：\n      "),e("ul",[e("li",[t._v("加速某些操作："),e("span",{staticClass:"ins"},[t._v("某些类型的匹配，比如"),e("span",{staticClass:"reg"},[t._v("/\\d+/")]),t._v("正则引擎会有特殊处理方案，执行速度比通用的处理机快！")])]),t._v(" "),e("li",[t._v("避免冗余操作："),e("span",{staticClass:"ins"},[t._v("如果正则引擎对于产生正确的结果来说，某些特殊的操作是不要的，或者某些操作能够应用到比之前更少的文本，忽略这些操作能够节省时间。比如"),e("span",{staticClass:"reg"},[t._v("/^A/")]),t._v("，只有在字符串开头位置才会匹配，如果在此处无法匹配，则宣告失败！")])])])])}]};var n=e("VU/8")({name:"Er"},a,!1,function(t){e("eL89")},"data-v-9fbdb190",null);s.default=n.exports},eL89:function(t,s){}});
//# sourceMappingURL=3.57daf0357a7f58186466.js.map