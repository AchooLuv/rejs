webpackJsonp([5],{"1u6f":function(s,t){},"968/":function(s,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var e={render:function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("div",{staticClass:"mpc-con"},[a("h2",[s._v("正则引擎的匹配规则")]),s._v(" "),a("p",[s._v("正则引擎的匹配规则可以归纳为两点：优先选择文本最左端的匹配结果；标准量词优先匹配！接下来将详细讲讲这两条规则：")]),s._v(" "),s._m(0),s._v(" "),s._m(1),s._v(" "),s._m(2),s._v(" "),a("p",[a("span",{staticClass:"ins"},[s._v("现在我们可以回过头来看"),a("router-link",{attrs:{to:"../../mc/single"}},[s._v("匹配单个字符型元字符")]),s._v("中怪异的例子了，先看这个最简单、最好理解的例子：")],1)]),s._v(" "),a("pre",{directives:[{name:"highlightjs",rawName:"v-highlightjs"}]},[s._v("    "),a("code",{staticClass:"javascript"},[s._v("      var regexp = /[Lo]/i,    // 只要其中任意一个字符匹配成功,便终止匹配\n      result = regexp.exec('AchooLuv');\n      console.log(result[0]);   // 匹配结果为: o 而非 L")]),s._v("\n  ")]),s._v(" "),s._m(3),s._v(" "),a("pre",{directives:[{name:"highlightjs",rawName:"v-highlightjs"}]},[s._v("    "),a("code",{staticClass:"javascript"},[s._v("      var regexp = /L|o/i,    // 不再使用字符组，改用多选分支\n      result = regexp.exec('AchooLuv');\n      console.log(result[0]);   // 匹配结果依然为: o 而非 L\n      console.log(result.index)   // 3  说明是在第一个字符o处匹配成功")]),s._v("\n  ")]),s._v(" "),s._m(4),s._v(" "),s._m(5),s._v(" "),a("pre",{directives:[{name:"highlightjs",rawName:"v-highlightjs"}]},[s._v("    "),a("code",{staticClass:"javascript"},[s._v("      var regexp = /[Lo]{2}/i,    // 或者写成 /(?:L|o){2}/\n      result = regexp.exec('AchooLuv');\n      console.log(result[0]);    // 匹配结果为: oo")]),s._v("\n  ")]),s._v(" "),s._m(6),s._v(" "),a("p",[a("span",{staticClass:"ins"},[a("router-link",{attrs:{to:"../../mc/counter"}},[s._v("标准匹配量词")]),s._v("都是“匹配优先”的，被这些量词修饰的表达式，在匹配成功之前，进行尝试的次数存在上限和下限，而该规则规定，这些尝试总是希望获得最长的匹配（即贪婪模式）！")],1)]),s._v(" "),s._m(7),s._v(" "),a("pre",{directives:[{name:"highlightjs",rawName:"v-highlightjs"}]},[s._v("    "),a("code",{staticClass:"javascript"},[s._v("      var regexp = /^.*(\\d\\d)/,    // 至少捕获两个数字\n      result = regexp.exec('Copyright 2017');\n      console.log(RegExp.$1);    // 匹配结果为: 17")]),s._v("\n  ")]),s._v(" "),s._m(8)])},staticRenderFns:[function(){var s=this.$createElement,t=this._self._c||s;return t("h3",[t("span",{staticClass:"iconfont jh"},[this._v("")]),this._v("优先选择文本最左端的匹配结果")])},function(){var s=this.$createElement,t=this._self._c||s;return t("p",[t("span",{staticClass:"ins"},[this._v("根据该规则，起始位置最靠左的匹配结果总是优先于其它可能的匹配结果，需要注意的是：该规则并未规定优先的匹配结果的长度，而只是规定，在所有的可能的匹配结果中，优先选择开始位置最左端的。")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("p",[t("span",{staticClass:"ins"},[this._v("该规则的由来：匹配先从需要查找的字符串的起始位置尝试匹配。此处“尝试匹配”的意思是：在当前位置测试整个正则表达式能匹配的每样文本。若在当前位置测试了所有可能之后不能找到匹配结果，就需要从字符串的第二个字符之前的位置开始重新尝试。在找到匹配结果以前必须在所有位置重复此过程，只有在尝试过所有的起始位置都不能找到匹配结果的情况下，才会宣告“匹配失败”！")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("p",[t("span",{staticClass:"ins"},[this._v("按照表达式列出的字符顺序，为什么不是优先匹配字符"),t("span",{staticClass:"reg"},[this._v("L")]),this._v("，而是匹配字符"),t("span",{staticClass:"reg"},[this._v("o")]),this._v("，为了更好理解，现在我们把上例改一改：")])])},function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("p",[a("span",{staticClass:"ins"},[s._v("用上面的匹配规则来解释这种现象就很好理解：为什么不是优先匹配字符"),a("span",{staticClass:"reg"},[s._v("L")]),s._v("，而是匹配字符"),a("span",{staticClass:"reg"},[s._v("o")]),s._v("了。在匹配时，基于表达式的传统型NFA引擎，首先在字符串"),a("span",{staticClass:"reg"},[s._v("AchooLuv")]),s._v("的第一个字符"),a("span",{staticClass:"reg"},[s._v("A")]),s._v("处，测试表达式中的"),a("span",{staticClass:"reg"},[s._v("L")]),s._v("和"),a("span",{staticClass:"reg"},[s._v("o")]),s._v("是否能够匹配，不能，则在下一位置，字符"),a("span",{staticClass:"reg"},[s._v("c")]),s._v("处再次测试，依然不能满足匹配，继续向后移动，直到在字符串中第一个字符"),a("span",{staticClass:"reg"},[s._v("o")]),s._v("处，测试表达式中的"),a("span",{staticClass:"reg"},[s._v("L")]),s._v("和"),a("span",{staticClass:"reg"},[s._v("o")]),s._v("时，此时字符"),a("span",{staticClass:"reg"},[s._v("o")]),s._v("满足匹配，结束整个匹配！")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("p",[t("span",{staticClass:"ins"},[this._v("再看其中的后一个例子，也是同样的道理：")])])},function(){var s=this.$createElement,t=this._self._c||s;return t("h3",[t("span",{staticClass:"iconfont jh"},[this._v("")]),this._v("标准量词优先匹配")])},function(){var s=this.$createElement,t=this._self._c||s;return t("p",[t("span",{staticClass:"ins"},[this._v("匹配优先量词之所以得名，是因为它们总是匹配多于匹配成功下限的字符！匹配优先量词虽然首先会尽可能匹配多的字符，但是为了整个表达式能够匹配成功，通常它们会“不情愿”的交还一些已匹配的字符。当然“交还”绝不能破坏匹配成立必须的条件，比如不允许零匹配的"),t("span",{staticClass:"reg"},[this._v("+")]),this._v("。来看个简单的例子：")])])},function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("p",[a("span",{staticClass:"ins"},[s._v("上例中，"),a("span",{staticClass:"reg"},[s._v(".*")]),s._v("匹配整个字符串"),a("span",{staticClass:"reg"},[s._v("Copyright 2017")]),s._v("，但是"),a("span",{staticClass:"reg"},[s._v("\\d\\d")]),s._v("必须匹配，此时"),a("span",{staticClass:"reg"},[s._v(".*")]),s._v("开始“交还”字符"),a("span",{staticClass:"reg"},[s._v("7")]),s._v("让"),a("span",{staticClass:"reg"},[s._v("\\d\\d")]),s._v("中第一个"),a("span",{staticClass:"reg"},[s._v("\\d")]),s._v("满足匹配，但是第二个"),a("span",{staticClass:"reg"},[s._v("\\d")]),s._v("不能满足匹配，"),a("span",{staticClass:"reg"},[s._v(".*")]),s._v("继续“交还”字符"),a("span",{staticClass:"reg"},[s._v("1")]),s._v("，此时"),a("span",{staticClass:"reg"},[s._v("\\d\\d")]),s._v("满足匹配，并被捕获，匹配结束")])])}]};var i=a("VU/8")({name:"Rules"},e,!1,function(s){a("1u6f")},"data-v-660d821a",null);t.default=i.exports}});
//# sourceMappingURL=5.3389cc895d19075871b8.js.map