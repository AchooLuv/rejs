{"version":3,"sources":["webpack:///src/pages/er/faster/Faster.vue","webpack:///./src/pages/er/faster/Faster.vue?7028","webpack:///./src/pages/er/faster/Faster.vue"],"names":["faster_Faster","render","this","$createElement","_self","_c","_m","staticRenderFns","_vm","_h","staticClass","_v","Component","__webpack_require__","normalizeComponent","name","ssrContext","__webpack_exports__"],"mappings":"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","file":"static/js/8.d1ba0f894c0f32648d69.js","sourcesContent":["<template>\r\n  <div class=\"erc-con\">\r\n    <h2>提高表达式速度的技巧</h2>\r\n    <p>传统型NFA引擎允许我们主导引擎更快地匹配，但有时提高了表达式的匹配效率，却让其难以维护和理解，所以更多的时候我们需要权衡，修改表达式带来好处的程度来决定应用以下这些技巧：</p>\r\n    <h3><span class=\"iconfont jh\">&#xe64a;</span>使用起始锚点</h3>\r\n    <p><span class=\"ins\">若以<span class=\"reg\">.*</span>开头的正则表达式都应在最前面添加<span class=\"reg\">^</span>或<span class=\"reg\">\\A</span>，因为，如果该表达式在某字符串开头不能匹配，那么它一定不能在该字符串的其它位置匹配。</span></p>\r\n    <h3><span class=\"iconfont jh\">&#xe64a;</span>使用非捕获型括号</h3>\r\n    <p><span class=\"ins\">若不需要引用括号内的文本，则使用非捕获型括号<span class=\"reg\">(?:)</span>。这样不但能节省捕获时间，而且还能减少回溯使用的状态数量。</span></p>\r\n    <h3><span class=\"iconfont jh\">&#xe64a;</span>从量词中“提取”必须的元素</h3>\r\n    <p><span class=\"ins\">比如，用<span class=\"reg\">xx*</span>替代<span class=\"reg\">x+</span>能“提取”必须匹配的<span class=\"reg\">x</span>。</span></p>\r\n    <h3><span class=\"iconfont jh\">&#xe64a;</span>“提取”多选结构开头的必须元素</h3>\r\n    <p><span class=\"ins\">比如，用<span class=\"reg\">regexp(?:er|js)</span>替代<span class=\"reg\">(?:regexper|regexpjs)</span>，提取必须匹配的元素<span class=\"reg\">regexp</span>。</span></p>\r\n    <h3><span class=\"iconfont jh\">&#xe64a;</span>在表达式前面或末尾独立出锚点</h3>\r\n    <p><span class=\"ins\"><span class=\"reg\">^(?:orz|luv)</span>和<span class=\"reg\">^orz|^luv</span>在逻辑上等价，但传统型NFA引擎只会对前者进行优化，所以前者的效率更高。独立出结尾锚点也是一样的原理，比如：<span class=\"reg\">(?:orz|luv)$</span>与<span class=\"reg\">orz$|luv$</span>。</span></p>\r\n    <h3><span class=\"iconfont jh\">&#xe64a;</span>拆分正则表达式</h3>\r\n    <p><span class=\"ins\">有时候，应用多个小正则表达式的速度比一个大正则表达式快的多，比如，依次检查<span class=\"reg\">orz</span>、<span class=\"reg\">luv</span>之类的速度要比检查<span class=\"reg\">orz|luv</span>的速度快，尤其是检查元素增多后。原因也很简单，因为后者不存在必须匹配成功的文字内容，故不会进行“内嵌文字字符串检查优化”。</span></p>\r\n    <h3><span class=\"iconfont jh\">&#xe64a;</span>模拟开头字符识别</h3>\r\n    <p><span class=\"ins\">通过在表达式开头添加环视结构进行手动的开头字符识别优化，在正则表达式的其他部分匹配之前，环视结构可以进行“预查”，选择合适的开始位置。比如可以将上例中的<span class=\"reg\">Orz|Luv</span>改写成肯定正序环视结构<span class=\"reg\">(?=[OL])(?:Orz|Luv)</span>，这样写的好处是匹配结果更精确，但性能可能会降。</span></p>\r\n    <h3><span class=\"iconfont jh\">&#xe64a;</span>使用固化分组与占有优先量词</h3>\r\n    <p><span class=\"ins\">在多数情况下，固化分组和占有优先量词能极大地提高匹配速度，而且不会改变匹配结果。比如<span class=\"reg\">^[^:]+:</span>中的冒号第一次尝试是无法匹配，那么任何回溯都是没有意义的。而使用固化分组<span class=\"reg\">^(?>[^:]+):</span>或者占有优先量词<span class=\"reg\">^[^:]++:</span>能直接抛弃备用状态或者根本不创建多少备用状态。由于引擎没有内容状态可以进行回溯，就不会进行不必要的回溯而增加开销。</span></p>\r\n    <h3><span class=\"iconfont jh\">&#xe64a;</span>将最可能匹配的多选分支放在前面</h3>\r\n    <p><span class=\"ins\">若匹配正确与顺序无关时，那么应该将最有可能匹配的多选分支放在首位，比如主机名匹配中的<span class=\"reg\">(?:com|org|net|cn|me)\\b</span>，将应用最广泛的排在最前面。</span></p>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: 'Faster'\r\n}\r\n</script>\r\n\r\n<style lang=\"scss\" scoped>\r\n@import 'sa/styles/var.scss';\r\n.erc-con {\r\n  @include tip;\r\n}\r\n</style>\r\n\n\n\n// WEBPACK FOOTER //\n// src/pages/er/faster/Faster.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"erc-con\"},[_c('h2',[_vm._v(\"提高表达式速度的技巧\")]),_vm._v(\" \"),_c('p',[_vm._v(\"传统型NFA引擎允许我们主导引擎更快地匹配，但有时提高了表达式的匹配效率，却让其难以维护和理解，所以更多的时候我们需要权衡，修改表达式带来好处的程度来决定应用以下这些技巧：\")]),_vm._v(\" \"),_c('h3',[_c('span',{staticClass:\"iconfont jh\"},[_vm._v(\"\")]),_vm._v(\"使用起始锚点\")]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"ins\"},[_vm._v(\"若以\"),_c('span',{staticClass:\"reg\"},[_vm._v(\".*\")]),_vm._v(\"开头的正则表达式都应在最前面添加\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"^\")]),_vm._v(\"或\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"\\\\A\")]),_vm._v(\"，因为，如果该表达式在某字符串开头不能匹配，那么它一定不能在该字符串的其它位置匹配。\")])]),_vm._v(\" \"),_c('h3',[_c('span',{staticClass:\"iconfont jh\"},[_vm._v(\"\")]),_vm._v(\"使用非捕获型括号\")]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"ins\"},[_vm._v(\"若不需要引用括号内的文本，则使用非捕获型括号\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"(?:)\")]),_vm._v(\"。这样不但能节省捕获时间，而且还能减少回溯使用的状态数量。\")])]),_vm._v(\" \"),_c('h3',[_c('span',{staticClass:\"iconfont jh\"},[_vm._v(\"\")]),_vm._v(\"从量词中“提取”必须的元素\")]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"ins\"},[_vm._v(\"比如，用\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"xx*\")]),_vm._v(\"替代\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"x+\")]),_vm._v(\"能“提取”必须匹配的\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"x\")]),_vm._v(\"。\")])]),_vm._v(\" \"),_c('h3',[_c('span',{staticClass:\"iconfont jh\"},[_vm._v(\"\")]),_vm._v(\"“提取”多选结构开头的必须元素\")]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"ins\"},[_vm._v(\"比如，用\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"regexp(?:er|js)\")]),_vm._v(\"替代\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"(?:regexper|regexpjs)\")]),_vm._v(\"，提取必须匹配的元素\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"regexp\")]),_vm._v(\"。\")])]),_vm._v(\" \"),_c('h3',[_c('span',{staticClass:\"iconfont jh\"},[_vm._v(\"\")]),_vm._v(\"在表达式前面或末尾独立出锚点\")]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"ins\"},[_c('span',{staticClass:\"reg\"},[_vm._v(\"^(?:orz|luv)\")]),_vm._v(\"和\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"^orz|^luv\")]),_vm._v(\"在逻辑上等价，但传统型NFA引擎只会对前者进行优化，所以前者的效率更高。独立出结尾锚点也是一样的原理，比如：\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"(?:orz|luv)$\")]),_vm._v(\"与\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"orz$|luv$\")]),_vm._v(\"。\")])]),_vm._v(\" \"),_c('h3',[_c('span',{staticClass:\"iconfont jh\"},[_vm._v(\"\")]),_vm._v(\"拆分正则表达式\")]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"ins\"},[_vm._v(\"有时候，应用多个小正则表达式的速度比一个大正则表达式快的多，比如，依次检查\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"orz\")]),_vm._v(\"、\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"luv\")]),_vm._v(\"之类的速度要比检查\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"orz|luv\")]),_vm._v(\"的速度快，尤其是检查元素增多后。原因也很简单，因为后者不存在必须匹配成功的文字内容，故不会进行“内嵌文字字符串检查优化”。\")])]),_vm._v(\" \"),_c('h3',[_c('span',{staticClass:\"iconfont jh\"},[_vm._v(\"\")]),_vm._v(\"模拟开头字符识别\")]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"ins\"},[_vm._v(\"通过在表达式开头添加环视结构进行手动的开头字符识别优化，在正则表达式的其他部分匹配之前，环视结构可以进行“预查”，选择合适的开始位置。比如可以将上例中的\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"Orz|Luv\")]),_vm._v(\"改写成肯定正序环视结构\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"(?=[OL])(?:Orz|Luv)\")]),_vm._v(\"，这样写的好处是匹配结果更精确，但性能可能会降。\")])]),_vm._v(\" \"),_c('h3',[_c('span',{staticClass:\"iconfont jh\"},[_vm._v(\"\")]),_vm._v(\"使用固化分组与占有优先量词\")]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"ins\"},[_vm._v(\"在多数情况下，固化分组和占有优先量词能极大地提高匹配速度，而且不会改变匹配结果。比如\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"^[^:]+:\")]),_vm._v(\"中的冒号第一次尝试是无法匹配，那么任何回溯都是没有意义的。而使用固化分组\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"^(?>[^:]+):\")]),_vm._v(\"或者占有优先量词\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"^[^:]++:\")]),_vm._v(\"能直接抛弃备用状态或者根本不创建多少备用状态。由于引擎没有内容状态可以进行回溯，就不会进行不必要的回溯而增加开销。\")])]),_vm._v(\" \"),_c('h3',[_c('span',{staticClass:\"iconfont jh\"},[_vm._v(\"\")]),_vm._v(\"将最可能匹配的多选分支放在前面\")]),_vm._v(\" \"),_c('p',[_c('span',{staticClass:\"ins\"},[_vm._v(\"若匹配正确与顺序无关时，那么应该将最有可能匹配的多选分支放在首位，比如主机名匹配中的\"),_c('span',{staticClass:\"reg\"},[_vm._v(\"(?:com|org|net|cn|me)\\\\b\")]),_vm._v(\"，将应用最广泛的排在最前面。\")])])])}]\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-319a8c7c\",\"hasScoped\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/pages/er/faster/Faster.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-319a8c7c\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!sass-loader?{\\\"sourceMap\\\":true}!../../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./Faster.vue\")\n}\nvar normalizeComponent = require(\"!../../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../../../node_modules/vue-loader/lib/selector?type=script&index=0!./Faster.vue\"\nimport __vue_script__ from \"!!babel-loader!../../../../node_modules/vue-loader/lib/selector?type=script&index=0!./Faster.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-319a8c7c\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../../node_modules/vue-loader/lib/selector?type=template&index=0!./Faster.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-319a8c7c\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/pages/er/faster/Faster.vue\n// module id = null\n// module chunks = "],"sourceRoot":""}